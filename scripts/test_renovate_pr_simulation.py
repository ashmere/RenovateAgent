#!/usr/bin/env python3
"""
Test script to simulate webhook events for Renovate PRs.
This tests the auto-approval functionality for any Renovate PR.
"""

import argparse
import hashlib
import hmac
import json
import os
from datetime import datetime

import requests


def create_hmac_signature(payload_body: str, secret: str) -> str:
    """Create HMAC signature for webhook payload."""
    signature = hmac.new(
        secret.encode("utf-8"), payload_body.encode("utf-8"), hashlib.sha256
    ).hexdigest()
    return f"sha256={signature}"


def simulate_pr_opened_event(
    org: str, repo: str, pr_number: int, title: str, bot_name: str
):
    """Simulate a Renovate PR being opened."""
    repo_name = repo.split("/")[1] if "/" in repo else repo
    full_name = f"{org}/{repo_name}"

    payload = {
        "action": "opened",
        "number": pr_number,
        "pull_request": {
            "id": 2345678900 + pr_number,
            "number": pr_number,
            "state": "open",
            "title": title,
            "body": (
                "This PR contains the following updates:\n\n"
                "| Package | Update | Change |\n|---|---|---|\n"
                "| [node](https://nodejs.org) | minor | "
                "`20.18.3` -> `20.19.3` |\n\n"
                "---\n\nThis PR has been generated by [Renovate Bot]"
                "(https://github.com/renovatebot/renovate)."
            ),
            "user": {
                "login": bot_name,
                "id": 29139614,
                "type": "Bot",
            },
            "head": {
                "ref": "renovate/node-20.x",
                "sha": "abc123def456",
                "repo": {
                    "name": repo_name,
                    "full_name": full_name,
                    "owner": {"login": org},
                    "private": True,
                },
            },
            "base": {
                "ref": "main",
                "sha": "def456abc123",
                "repo": {
                    "name": repo_name,
                    "full_name": full_name,
                    "owner": {"login": org},
                },
            },
            "mergeable": True,
            "mergeable_state": "clean",
            "draft": False,
            "html_url": f"https://github.com/{full_name}/pull/{pr_number}",
            "created_at": "2025-07-07T13:23:19Z",
            "updated_at": "2025-07-07T13:23:19Z",
        },
        "repository": {
            "id": 123456789,
            "name": repo_name,
            "full_name": full_name,
            "owner": {"login": org, "id": 87654321, "type": "Organization"},
            "private": True,
            "html_url": f"https://github.com/{full_name}",
        },
        "organization": {"login": org, "id": 87654321},
        "sender": {
            "login": bot_name,
            "id": 29139614,
            "type": "Bot",
        },
    }
    return payload


def simulate_check_suite_completed_event(org: str, repo: str, pr_number: int):
    """Simulate all checks passing for a PR."""
    repo_name = repo.split("/")[1] if "/" in repo else repo
    full_name = f"{org}/{repo_name}"

    payload = {
        "action": "completed",
        "check_suite": {
            "id": 987654321,
            "status": "completed",
            "conclusion": "success",
            "head_branch": "renovate/node-20.x",
            "head_sha": "abc123def456",
            "pull_requests": [
                {
                    "id": 2345678900 + pr_number,
                    "number": pr_number,
                    "head": {"ref": "renovate/node-20.x", "sha": "abc123def456"},
                    "base": {"ref": "main", "sha": "def456abc123"},
                }
            ],
        },
        "repository": {
            "id": 123456789,
            "name": repo_name,
            "full_name": full_name,
            "owner": {"login": org, "id": 87654321, "type": "Organization"},
            "private": True,
        },
        "organization": {"login": org, "id": 87654321},
    }
    return payload


def send_webhook(event_type: str, payload: dict, description: str, base_url: str):
    """Send a webhook event to the local server."""
    url = f"{base_url}/webhooks/github"

    # Get webhook secret from environment
    webhook_secret = os.getenv("GITHUB_WEBHOOK_SECRET", "dev-secret")

    # Convert payload to JSON
    payload_body = json.dumps(payload)

    # Create signature
    signature = create_hmac_signature(payload_body, webhook_secret)

    # Headers
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    headers = {
        "Content-Type": "application/json",
        "X-GitHub-Event": event_type,
        "X-GitHub-Delivery": f"12345678-1234-5678-9012-{timestamp}",
        "X-Hub-Signature-256": signature,
        "User-Agent": "GitHub-Hookshot/abc123",
    }

    print(f"ğŸ“¤ Sending {event_type} webhook: {description}")
    print(f"   URL: {url}")
    print(f"   Payload size: {len(payload_body)} bytes")

    try:
        response = requests.post(url, data=payload_body, headers=headers, timeout=10)
        print(f"   Status: {response.status_code}")

        if response.status_code == 200:
            try:
                response_data = response.json()
                success_msg = response_data.get("message", "No message")
                print(f"   âœ… Success: {success_msg}")
                if "result" in response_data:
                    result = response_data["result"]
                    if isinstance(result, dict):
                        action = result.get("action", "unknown")
                        message = result.get("message", "No details")
                        print(f"   ğŸ“‹ Action: {action}")
                        print(f"   ğŸ“ Details: {message}")
                    else:
                        print(f"   ğŸ“‹ Result: {result}")
            except json.JSONDecodeError:
                print(f"   âœ… Success: {response.text}")
        else:
            print(f"   âŒ Error: {response.status_code}")
            try:
                error_data = response.json()
                print(f"   ğŸ“ Error details: {error_data}")
            except json.JSONDecodeError:
                print(f"   ğŸ“ Error text: {response.text}")

        print()
        return response.status_code == 200

    except requests.exceptions.RequestException as e:
        print(f"   âŒ Request failed: {e}")
        print()
        return False


def main():
    """Run the Renovate PR simulation test."""
    parser = argparse.ArgumentParser(
        description="Simulate Renovate PR webhooks for testing auto-approval"
    )
    parser.add_argument("--org", required=True, help="GitHub organization name")
    parser.add_argument("--repo", required=True, help="Repository name")
    parser.add_argument("--pr", type=int, required=True, help="PR number to simulate")
    parser.add_argument(
        "--title",
        default="chore(deps): update dependency to latest version",
        help="PR title (default: generic dependency update)",
    )
    parser.add_argument("--bot-name", help="Bot name (default: renovate-{org}[bot])")
    parser.add_argument(
        "--url",
        default="http://localhost:8000",
        help="Server URL (default: http://localhost:8000)",
    )

    args = parser.parse_args()

    # Set default bot name if not provided
    bot_name = args.bot_name or f"renovate-{args.org}[bot]"

    print("ğŸ¯ Renovate PR Auto-Approval Simulation")
    print("=" * 50)
    print()
    pr_url = f"https://github.com/{args.org}/{args.repo}/pull/{args.pr}"
    print(f"ğŸ“ Testing PR: {pr_url}")
    print(f"ğŸ“‹ Title: {args.title}")
    print(f"ğŸ¤– Bot: {bot_name}")
    print(f"ğŸŒ Server: {args.url}")
    print()

    # Check if server is running
    try:
        health_response = requests.get(f"{args.url}/health", timeout=5)
        if health_response.status_code != 200:
            print("âŒ Server not responding to health check")
            return False
        print("âœ… Server is running and healthy")
        print()
    except requests.exceptions.RequestException:
        print(f"âŒ Cannot connect to server. Is it running on {args.url}?")
        return False

    # Test sequence
    print("ğŸ§ª Webhook Event Sequence")
    print("=" * 30)
    print()

    success_count = 0
    total_tests = 2

    # 1. Simulate PR opened
    pr_payload = simulate_pr_opened_event(
        args.org, args.repo, args.pr, args.title, bot_name
    )
    if send_webhook(
        "pull_request", pr_payload, f"PR #{args.pr} opened by Renovate", args.url
    ):
        success_count += 1

    # 2. Simulate checks completed (all passing)
    check_payload = simulate_check_suite_completed_event(args.org, args.repo, args.pr)
    if send_webhook(
        "check_suite", check_payload, f"All checks passed for PR #{args.pr}", args.url
    ):
        success_count += 1

    # Results
    print("ğŸ“Š Test Results")
    print("=" * 15)
    print(f"âœ… Successful webhooks: {success_count}/{total_tests}")

    if success_count == total_tests:
        print("ğŸ‰ All tests passed! PR simulation completed successfully.")
        print()
        print("ğŸ” Expected behavior:")
        print("   â€¢ PR should be detected as a Renovate PR")
        print("   â€¢ System should verify all checks are passing")
        print("   â€¢ PR should be automatically approved")
        print("   â€¢ Dashboard issue should be updated")
        print()
        print("ğŸ“ Check the server logs for detailed processing information.")
        return True
    else:
        print("âŒ Some tests failed. Check server logs for details.")
        return False


if __name__ == "__main__":
    main()
